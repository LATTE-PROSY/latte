<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Minesweeper — Google-style Copy</title>
<style>
  :root{
    --bg: #f6f9fc;
    --card: #fff;
    --accent: #1a73e8;
    --text: #202124;
    --muted: #5f6368;
    --cell-size: 36px;
    --cell-gap: 6px;
    --shadow: 0 4px 12px rgba(32,33,36,.08);
  }
  html,body{
    height:100%;
    margin:0;
    background: linear-gradient(180deg,#eef4ff 0%,var(--bg) 100%);
    font-family: "Google Sans", "Segoe UI", Roboto, Arial, sans-serif;
    color:var(--text);
    -webkit-font-smoothing:antialiased;
  }
  .wrap{
    min-height:100%;
    display:flex;
    align-items:center;
    justify-content:center;
    padding:28px;
  }
  .card{
    background:var(--card);
    border-radius:12px;
    box-shadow:var(--shadow);
    padding:20px;
    width: fit-content;
    max-width: calc(100vw - 40px);
  }
  .header{
    display:flex;
    gap:12px;
    align-items:center;
    margin-bottom:14px;
  }
  .title{
    display:flex;
    flex-direction:column;
  }
  .title h1{
    margin:0;
    font-size:18px;
    font-weight:600;
  }
  .title p{
    margin:0;
    color:var(--muted);
    font-size:12px;
  }
  .controls{
    margin-left:auto;
    display:flex;
    gap:8px;
    align-items:center;
  }
  .btn, .smiley{
    border: none;
    background: transparent;
    cursor: pointer;
    padding:6px 10px;
    border-radius:8px;
    font-weight:600;
    color:var(--text);
  }
  .select{
    border-radius:8px;
    padding:6px 8px;
    border:1px solid #e6e9ee;
    background:#fff;
  }
  .statusbar{
    display:flex;
    gap:8px;
    align-items:center;
    margin-bottom:12px;
  }
  .counter{
    background:#000;
    color:#fff;
    font-family:monospace;
    padding:6px 10px;
    border-radius:6px;
    min-width:68px;
    text-align:center;
    font-weight:700;
    letter-spacing:1px;
  }
  .smiley{
    background: linear-gradient(180deg,#fff,#f1f5ff);
    border-radius:8px;
    border:1px solid #e6e9ee;
    width:44px;
    height:44px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:18px;
  }
  .timer{
    font-family:monospace;
    background:#000;
    color:#fff;
    padding:6px 10px;
    border-radius:6px;
    min-width:68px;
    text-align:center;
    font-weight:700;
    letter-spacing:1px;
  }
  .board{
    display:grid;
    gap: var(--cell-gap);
    background: transparent;
    padding:10px;
    touch-action: manipulation;
    user-select:none;
  }
  .cell{
    width:var(--cell-size);
    height:var(--cell-size);
    display:flex;
    align-items:center;
    justify-content:center;
    border-radius:6px;
    font-weight:700;
    cursor:pointer;
    font-size:16px;
    box-shadow: 0 1px 0 rgba(255,255,255,.6) inset, 0 -1px 0 rgba(0,0,0,.02) inset;
    background: linear-gradient(180deg,#eef3ff,#ffffff);
    border:1px solid #d6dbe8;
    color:var(--text);
  }
  .cell.revealed{
    background: linear-gradient(180deg,#f3f4f6,#e9eefb);
    border:1px solid rgba(0,0,0,.05);
    box-shadow:none;
    cursor:default;
  }
  .cell.mine{
    background: linear-gradient(180deg,#ffefef,#ffdede);
    color:#a70000;
  }
  .cell.flag{
    background: linear-gradient(180deg,#fff9ec,#fff1d6);
    color:#d46b08;
  }
  .cell.disabled{
    pointer-events:none;
    opacity:0.95;
  }
  .cell .label{pointer-events:none;}
  .row-info{display:flex; gap:6px; align-items:center; margin-bottom:8px;}
  .footer{margin-top:12px; color:var(--muted); font-size:13px; text-align:center;}
  /* number colors (classic-ish) */
  .n1{color:#1565c0}
  .n2{color:#2e7d32}
  .n3{color:#c62828}
  .n4{color:#4527a0}
  .n5{color:#b71c1c}
  .n6{color:#00796b}
  .n7{color:#263238}
  .n8{color:#6b6b6b}
  @media (max-width:520px){
    :root{--cell-size:30px; --cell-gap:5px}
    .card{padding:12px}
    .header{gap:8px}
    .title h1{font-size:16px}
    .smiley{width:40px;height:40px}
  }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card" role="application" aria-label="Minesweeper">
      <div class="header">
        <div class="title">
          <h1>Minesweeper</h1>
          <p>Classic mine-hunting fun — left click to reveal, right click to flag.</p>
        </div>

        <div class="controls">
          <label>
            Difficulty
            <select id="difficulty" class="select" aria-label="Difficulty">
              <option value="easy">Easy (9×9, 10 mines)</option>
              <option value="medium" selected>Medium (16×16, 40 mines)</option>
              <option value="hard">Hard (24×18, 99 mines)</option>
            </select>
          </label>

          <button class="smiley" id="restart" title="Restart" aria-label="Restart">🙂</button>
        </div>
      </div>

      <div class="statusbar" aria-hidden="false">
        <div class="counter" id="mineCount">000</div>
        <div style="width:12px"></div>
        <div class="timer" id="timer">000</div>
      </div>

      <div id="board" class="board" tabindex="0" aria-label="Minesweeper board"></div>

      <div class="footer">
        <small>Right-click (or long-press on touch) to toggle flags. Good luck!</small>
      </div>
    </div>
  </div>

<script>
(() => {
  // Configs for difficulties
  const DIFFS = {
    easy:   {cols:9, rows:9, mines:10},
    medium: {cols:16, rows:16, mines:40},
    hard:   {cols:24, rows:18, mines:99}
  };

  // DOM
  const boardEl = document.getElementById('board');
  const mineCountEl = document.getElementById('mineCount');
  const timerEl = document.getElementById('timer');
  const restartBtn = document.getElementById('restart');
  const difficultySelect = document.getElementById('difficulty');

  // Game state
  let cols, rows, totalMines;
  let grid = []; // cells
  let plantingDone = false;
  let revealedCount = 0;
  let flags = 0;
  let timer = null;
  let startTime = null;
  let gameOver = false;
  let longPressTimer = null;

  function resetTimer(){
    clearInterval(timer);
    timer = null;
    startTime = null;
    timerEl.textContent = formatNumber(0);
  }

  function startTimer(){
    if (timer) return;
    startTime = Date.now();
    timer = setInterval(()=> {
      const seconds = Math.floor((Date.now() - startTime)/1000);
      timerEl.textContent = formatNumber(Math.min(seconds, 999));
    }, 250);
  }

  function formatNumber(n){
    return String(n).padStart(3, '0');
  }

  function setDifficulty(diff){
    const d = DIFFS[diff] || DIFFS.medium;
    cols = d.cols; rows = d.rows; totalMines = d.mines;
    mineCountEl.textContent = formatNumber(totalMines);
    initBoard();
  }

  function createCell(r,c){
    return {
      r, c,
      mine:false,
      revealed:false,
      flagged:false,
      adj:0,
      el: null
    };
  }

  function initBoard(){
    // reset
    plantingDone = false;
    revealedCount = 0;
    flags = 0;
    gameOver = false;
    resetTimer();
    restartBtn.textContent = '🙂';
    boardEl.innerHTML = '';
    grid = [];
    // grid
    for(let r=0;r<rows;r++){
      const row = [];
      for(let c=0;c<cols;c++) row.push(createCell(r,c));
      grid.push(row);
    }
    // style board grid
    boardEl.style.gridTemplateColumns = `repeat(${cols}, var(--cell-size))`;
    boardEl.style.gridTemplateRows = `repeat(${rows}, var(--cell-size))`;
    // create DOM
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = grid[r][c];
        const el = document.createElement('button');
        el.className = 'cell';
        el.dataset.r = r; el.dataset.c = c;
        el.setAttribute('aria-label', `cell ${r+1},${c+1}`);
        el.addEventListener('click', onCellClick);
        el.addEventListener('contextmenu', onCellRightClick);
        // touch long-press for flagging
        el.addEventListener('touchstart', (e) => {
          e.stopPropagation();
          longPressTimer = setTimeout(()=> {
            toggleFlag(cell);
          }, 450);
        }, {passive:true});
        el.addEventListener('touchend', () => {
          if (longPressTimer) clearTimeout(longPressTimer);
        });
        // also support mousedown -> start long-press on desktop for accessibility
        el.addEventListener('mousedown', (e) => {
          if (e.button === 2) return;
          longPressTimer = setTimeout(()=> {
            toggleFlag(cell);
          }, 700);
        });
        el.addEventListener('mouseup', () => {
          if (longPressTimer) clearTimeout(longPressTimer);
        });

        cell.el = el;
        boardEl.appendChild(el);
      }
    }
  }

  function onCellClick(e){
    if (gameOver) return;
    const el = e.currentTarget;
    const r = +el.dataset.r, c = +el.dataset.c;
    const cell = grid[r][c];
    if (!plantingDone){
      plantMines(r,c); // ensure first click safe
      plantingDone = true;
      startTimer();
    }
    if (cell.flagged || cell.revealed) return;
    revealCell(cell);
    checkWin();
  }

  function onCellRightClick(e){
    e.preventDefault();
    if (gameOver) return;
    const el = e.currentTarget;
    const r = +el.dataset.r, c = +el.dataset.c;
    const cell = grid[r][c];
    if (!plantingDone){
      plantMines(r,c);
      plantingDone = true;
      startTimer();
    }
    toggleFlag(cell);
    checkWin();
  }

  function plantMines(skipR, skipC){
    // place totalMines randomly, avoid the first clicked cell and neighbors
    const safe = new Set();
    for(let dr=-1;dr<=1;dr++){
      for(let dc=-1;dc<=1;dc++){
        const rr = skipR+dr, cc = skipC+dc;
        if (inBounds(rr,cc)) safe.add(rr + ',' + cc);
      }
    }
    let placed = 0;
    while(placed < totalMines){
      const r = Math.floor(Math.random()*rows);
      const c = Math.floor(Math.random()*cols);
      const key = r+','+c;
      if (safe.has(key)) continue;
      const cell = grid[r][c];
      if (cell.mine) continue;
      cell.mine = true;
      placed++;
    }
    // compute adjacents
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = grid[r][c];
        if (cell.mine) continue;
        let adj=0;
        for(let dr=-1;dr<=1;dr++){
          for(let dc=-1;dc<=1;dc++){
            if (dr===0 && dc===0) continue;
            const rr=r+dr, cc=c+dc;
            if (inBounds(rr,cc) && grid[rr][cc].mine) adj++;
          }
        }
        cell.adj = adj;
      }
    }
  }

  function inBounds(r,c){ return r>=0 && c>=0 && r<rows && c<cols; }

  function revealCell(cell){
    if (cell.revealed || cell.flagged) return;
    cell.revealed = true;
    revealedCount++;
    const el = cell.el;
    el.classList.add('revealed');
    el.classList.remove('flag');
    el.innerHTML = '<span class="label"></span>';
    const label = el.querySelector('.label');
    if (cell.mine){
      el.classList.add('mine');
      label.textContent = '💣';
      endGame(false, cell);
      return;
    }
    if (cell.adj === 0){
      label.textContent = '';
      // flood reveal
      for(let dr=-1;dr<=1;dr++){
        for(let dc=-1;dc<=1;dc++){
          const rr = cell.r+dr, cc = cell.c+dc;
          if (inBounds(rr,cc) && !(dr===0 && dc===0)){
            const n = grid[rr][cc];
            if (!n.revealed && !n.flagged) revealCell(n);
          }
        }
      }
    } else {
      label.textContent = cell.adj;
      label.className = 'label n' + cell.adj;
    }
    el.classList.add('disabled');
  }

  function toggleFlag(cell){
    if (cell.revealed) return;
    cell.flagged = !cell.flagged;
    const el = cell.el;
    if (cell.flagged){
      el.classList.add('flag');
      el.innerHTML = '<span class="label">🚩</span>';
      flags++;
    } else {
      el.classList.remove('flag');
      el.innerHTML = '';
      flags = Math.max(0, flags-1);
    }
    mineCountEl.textContent = formatNumber(Math.max(0, totalMines - flags));
  }

  function endGame(won, triggeredCell){
    gameOver = true;
    clearInterval(timer);
    timer = null;
    // reveal all mines on loss
    for(let r=0;r<rows;r++){
      for(let c=0;c<cols;c++){
        const cell = grid[r][c];
        if (cell.mine){
          if (!cell.revealed){
            cell.el.classList.add('revealed','mine');
            cell.el.innerHTML = '<span class="label">💣</span>';
          }
        }
        if (cell.flagged && !cell.mine){
          // wrongly flagged
          cell.el.innerHTML = '<span class="label">❌</span>';
        }
        cell.el.classList.add('disabled');
      }
    }
    if (won){
      restartBtn.textContent = '😎';
      // highlight flags maybe
    } else {
      restartBtn.textContent = '😵';
      if (triggeredCell) {
        triggeredCell.el.style.background = 'linear-gradient(180deg,#ffdede,#ffefef)';
      }
    }
  }

  function checkWin(){
    // win when all non-mine cells revealed OR flags == mines and all flags on mines
    const totalCells = cols * rows;
    if (revealedCount === totalCells - totalMines){
      // mark all remaining mines as flagged visually
      for(let r=0;r<rows;r++){
        for(let c=0;c<cols;c++){
          const cell = grid[r][c];
          if (cell.mine && !cell.flagged){
            cell.flagged = true;
            cell.el.classList.add('flag');
            cell.el.innerHTML = '<span class="label">🚩</span>';
          }
          cell.el.classList.add('disabled');
        }
      }
      endGame(true);
    }
  }

  // restart handler
  restartBtn.addEventListener('click', () => {
    setDifficulty(difficultySelect.value);
  });

  difficultySelect.addEventListener('change', () => {
    setDifficulty(difficultySelect.value);
  });

  // keyboard accessibility: arrow keys to move focus, space/enter to reveal, F to flag
  boardEl.addEventListener('keydown', (e) => {
    const focus = document.activeElement;
    if (!focus || !focus.classList.contains('cell')) {
      // focus the first cell
      boardEl.querySelector('.cell')?.focus();
    } else {
      let r = +focus.dataset.r, c = +focus.dataset.c;
      if (e.key === 'ArrowUp'){ r = Math.max(0, r-1); boardEl.querySelector(`[data-r="${r}"][data-c="${c}"]`)?.focus(); e.preventDefault();}
      if (e.key === 'ArrowDown'){ r = Math.min(rows-1, r+1); boardEl.querySelector(`[data-r="${r}"][data-c="${c}"]`)?.focus(); e.preventDefault();}
      if (e.key === 'ArrowLeft'){ c = Math.max(0, c-1); boardEl.querySelector(`[data-r="${r}"][data-c="${c}"]`)?.focus(); e.preventDefault();}
      if (e.key === 'ArrowRight'){ c = Math.min(cols-1, c+1); boardEl.querySelector(`[data-r="${r}"][data-c="${c}"]`)?.focus(); e.preventDefault();}
      if (e.key === ' ' || e.key === 'Enter'){ focus.click(); e.preventDefault();}
      if (e.key.toLowerCase() === 'f'){ focus.dispatchEvent(new Event('contextmenu', {bubbles:true,cancelable:true})); e.preventDefault();}
    }
  });

  // prevent context menu on board (so right-click flags instead of showing context menu)
  boardEl.addEventListener('contextmenu', (e)=> e.preventDefault());

  // initialize
  setDifficulty(difficultySelect.value);

  // expose some debug/game functions on window for tinkering
  window.MS = {
    new: (d) => setDifficulty(d || 'medium'),
    getState: ()=> ({cols,rows,totalMines,flags,revealedCount,gameOver})
  };
})();
</script>
</body>
</html>
